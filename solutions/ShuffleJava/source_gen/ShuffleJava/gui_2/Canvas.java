package ShuffleJava.gui_2;

/*Generated by MPS */

import javax.swing.JPanel;
import java.awt.Font;
import java.util.List;
import java.util.Map;
import java.awt.image.BufferedImage;
import ShuffleJava.runtime.GameState;
import java.awt.Dimension;
import java.util.ArrayList;
import java.util.HashMap;
import javax.imageio.ImageIO;
import java.io.IOException;
import java.awt.Graphics;
import java.awt.Color;

public class Canvas extends JPanel {

  private static int X = 0;
  private static int Y = 1;

  private static int CELL_HEIGHT = 112;
  private static int CELL_WIDTH = 100;

  private static float SPACE_ON_X = 100;
  public static Font font = new Font("Monospaced", Font.PLAIN, 12);



  private static float TOP_BOTTOM_X;
  private static float TOP_Y;
  private static float BOTTOM_Y;
  private static float LEFT_X;
  private static float RIGHT_X;
  private static float LEFT_RIGHT_Y;

  private Integer[] canvasSize;

  public List<ShuffleDraw> components;
  public Map<ShuffleDraw, Float[]> locations;
  private ShuffleMouseEvents mountEvents;
  private BufferedImage bgImg;


  public Canvas(int width, int height, GameState g) {
    this.setPreferredSize(new Dimension(width, height));

    canvasSize = new Integer[2];
    this.canvasSize[X] = width;
    this.canvasSize[Y] = height;

    TOP_Y = ((float) 10) / canvasSize[Y];
    BOTTOM_Y = 1.0f - ((float) (CardDisplay.CARD_HEIGHT + 10)) / canvasSize[Y];
    LEFT_X = ((float) 10) / canvasSize[X];
    RIGHT_X = 1.0f - ((float) (CardDisplay.CARD_WIDTH + 10)) / canvasSize[X];
    LEFT_RIGHT_Y = 0.0f + ((float) (CardDisplay.CARD_HEIGHT + 10)) / canvasSize[Y];


    components = new ArrayList<ShuffleDraw>();
    locations = new HashMap<ShuffleDraw, Float[]>();

    ClassLoader classLoader = getClass().getClassLoader();
    try {
      bgImg = ImageIO.read(classLoader.getResource("background.jpg"));

    } catch (IOException e) {
      System.out.println("ERROR: Canvas: background image not found");
    }


    this.mountEvents = new ShuffleMouseEvents(components, locations, canvasSize, g);
    this.addMouseListener(this.mountEvents);
    this.addMouseMotionListener(this.mountEvents);
  }



  public void addShuffleComponent(ShuffleDraw sd, String c, int i) {
    components.add(sd);
    Float[] proportions = cellToLocation(c, i);
    locations.put(sd, proportions);
  }



  public void addShuffleComponent(ShuffleDraw sd, int playerNumber, int numberOfPlayers) {
    components.add(sd);
    HandDisplay hd = ((HandDisplay) sd);
    Float[] proportions = playerToLocation(playerNumber, numberOfPlayers, hd.getHandSize());
    locations.put(sd, proportions);
  }




  public boolean removeShuffleComponent(ShuffleDraw sd) {
    if (!(components.contains(sd))) {
      return false;
    }
    components.remove(sd);
    locations.remove(sd);
    return true;
  }



  public void paintComponent(Graphics g) {
    super.paintComponent(g);
    g.drawImage(bgImg, 0, 0, Color.WHITE, null);
    g.setFont(font);
    // Paint every item in the comoonents list 
    for (ShuffleDraw d : components) {
      // compute x and y 
      Float[] locationProportions = locations.get(d);
      int x = (int) (canvasSize[X] * locationProportions[X]);
      int y = (int) (canvasSize[Y] * locationProportions[Y]);
      d.draw(g, x, y);
    }
  }



  public Float[] cellToLocation(String xCell, int yCell) {
    float y = (yCell - 1) * CELL_HEIGHT + CELL_HEIGHT;
    int xCellD = xCell.charAt(0) - 'A';
    float x = (xCellD - 1) * CELL_WIDTH + CELL_WIDTH + SPACE_ON_X;
    Float[] proportions = new Float[2];
    proportions[X] = x / (float) canvasSize[X];
    proportions[Y] = y / (float) canvasSize[Y];
    return proportions;
  }



  private Float[] playerToLocation(int playerNumber, int numPlayers, int size) {
    Float[] proportions = new Float[2];
    float totalPileSize;
    float emptySpace;


    if (playerNumber < 1 || playerNumber > 4 || numPlayers < 1 || numPlayers > 4) {
      System.out.println("ERROR in canvas: player to location, invalid player number");
      proportions[X] = 1.0f;
      proportions[Y] = 1.0f;
      return proportions;
    }

    if (playerNumber == 1) {
      totalPileSize = size * CardDisplay.CARD_WIDTH;
      emptySpace = canvasSize[X] - totalPileSize;
      proportions[X] = (float) emptySpace / ((float) (2 * canvasSize[X]));
      proportions[Y] = BOTTOM_Y;
    } else {
      if (numPlayers > 2) {
        switch (playerNumber) {
          case 2:
            totalPileSize = size * CardDisplay.CARD_HEIGHT / 2;
            emptySpace = canvasSize[Y] - totalPileSize;
            proportions[X] = LEFT_X;
            proportions[Y] = (float) emptySpace / ((float) (2 * canvasSize[Y]));

            break;
          case 3:
            totalPileSize = size * CardDisplay.CARD_WIDTH;
            emptySpace = canvasSize[X] - totalPileSize;
            proportions[X] = (float) emptySpace / ((float) (2 * canvasSize[X]));
            proportions[Y] = TOP_Y;
            break;
          case 4:
            totalPileSize = size * CardDisplay.CARD_HEIGHT / 2;
            emptySpace = canvasSize[Y] - totalPileSize;
            proportions[X] = RIGHT_X;
            proportions[Y] = (float) emptySpace / ((float) (2 * canvasSize[Y]));
            break;
          default:
        }
      } else {
        // player2, 2 players 
        totalPileSize = size * CardDisplay.CARD_WIDTH;
        emptySpace = canvasSize[X] - totalPileSize;
        proportions[X] = (float) emptySpace / ((float) (2 * canvasSize[X]));
        proportions[Y] = TOP_Y;
      }
    }
    return proportions;
  }
}
