package ShuffleJava.gui_2;

/*Generated by MPS */

import javax.swing.JPanel;
import java.util.List;
import java.util.Map;
import java.awt.image.BufferedImage;
import ShuffleJava.runtime.GameState;
import java.awt.Dimension;
import java.util.ArrayList;
import java.util.HashMap;
import javax.imageio.ImageIO;
import java.io.IOException;
import java.awt.Graphics;
import java.awt.Color;

public class Canvas extends JPanel {

  private static int X = 0;
  private static int Y = 1;


  private Integer[] canvasSize;

  public List<ShuffleDraw> components;
  public Map<ShuffleDraw, Float[]> locations;
  private ShuffleMouseEvents mountEvents;
  private BufferedImage bgImg;


  public Canvas(int width, int height, GameState g) {
    this.setPreferredSize(new Dimension(width, height));

    canvasSize = new Integer[2];
    this.canvasSize[X] = width;
    this.canvasSize[Y] = height;

    components = new ArrayList<ShuffleDraw>();
    locations = new HashMap<ShuffleDraw, Float[]>();

    ClassLoader classLoader = getClass().getClassLoader();
    try {
      bgImg = ImageIO.read(classLoader.getResource("background.png"));

    } catch (IOException e) {
      System.out.println("ERROR: Canvas: background image not found");
    }


    this.mountEvents = new ShuffleMouseEvents(components, locations, canvasSize, g);
    this.addMouseListener(this.mountEvents);
  }



  public void addShuffleComponent(ShuffleDraw sd, String c, int i) {
    components.add(sd);
    Float[] proportions = cellToLocation(c, i);
    locations.put(sd, proportions);
  }



  public void addShuffleComponent(ShuffleDraw sd, int playerNumber, int numberOfPlayers) {
    components.add(sd);
    Float[] proportions = playerToLocation(playerNumber);
    locations.put(sd, proportions);
  }




  public boolean removeShuffleComponent(ShuffleDraw sd) {
    if (!(components.contains(sd))) {
      return false;
    }
    components.remove(sd);
    locations.remove(sd);
    return true;
  }



  public void paintComponent(Graphics g) {
    super.paintComponent(g);
    g.drawImage(bgImg, 0, 0, Color.WHITE, null);
    // Paint every item in the comoonents list 
    for (ShuffleDraw d : components) {
      // compute x and y 
      Float[] locationProportions = locations.get(d);
      int x = (int) (canvasSize[X] * locationProportions[X]);
      int y = (int) (canvasSize[Y] * locationProportions[Y]);
      d.draw(g, x, y);
    }
  }



  public Float[] cellToLocation(String xCell, int yCell) {
    float y = (yCell - 1) * StackedPileDisplay.STACK_HEIGHT + StackedPileDisplay.STACK_HEIGHT * 1.3f;
    int xCellD = xCell.charAt(0) - 'A';
    float x = StackedPileDisplay.STACK_WIDTH * 1.3f + xCellD * 55;
    Float[] proportions = new Float[2];
    proportions[X] = x / (float) canvasSize[X];
    proportions[Y] = y / (float) canvasSize[Y];
    return proportions;
  }



  private Float[] playerToLocation(int playerNumber) {
    Float[] proportions = new Float[2];
    // border of 10px 
    switch (playerNumber) {
      case 1:
        proportions[X] = 0.0f + ((float) (CardDisplay.CARD_WIDTH + 10)) / canvasSize[X];
        proportions[Y] = 1.0f - ((float) (CardDisplay.CARD_HEIGHT + 10)) / canvasSize[Y];
        break;
      case 2:
        proportions[X] = 0.0f + ((float) (CardDisplay.CARD_WIDTH + 10)) / canvasSize[X];
        proportions[Y] = ((float) 10) / canvasSize[Y];
        break;
      case 3:
        // todo: this is on the side, it should start at 0,0 and grow down, not sideways 
        proportions[X] = ((float) 10) / canvasSize[X];
        proportions[Y] = 0.0f + ((float) (CardDisplay.CARD_HEIGHT + 10)) / canvasSize[Y];
        break;
      case 4:
        // todo: this is on the side, it should start at 1,0 and grow down, not sideways 
        proportions[X] = 1.0f - ((float) (CardDisplay.CARD_WIDTH + 10)) / canvasSize[X];
        proportions[Y] = 0.0f + ((float) (CardDisplay.CARD_HEIGHT + 10)) / canvasSize[Y];
        break;
      default:
        System.out.println("ERROR in canvas: player to location, invalid player number");
        proportions[X] = 1.0f;
        proportions[Y] = 1.0f;

    }
    return proportions;
  }
}
